---
title: 迭代器和生成器
order: 18
toc: content
nav:
  path: /frontend
  title: 前端
  order: 1
group:
  path: /JavaScript
  title: JavaScript
  order: 3
---

## 迭代器

### 背景知识

#### 什么是迭代？

从一个数据集合中按照一定的顺序，不断取出数据的过程

#### 迭代和遍历的区别？

迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完

遍历强调的是要把整个数据依次全部取出

#### 迭代器

对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象

#### 迭代模式

一种设计模式，用于统一迭代过程，并规范了迭代器规格：

- 迭代器应该具有得到下一个数据的能力
- 迭代器应该具有判断是否还有后续数据的能力

### JS 中的迭代器

JS 规定，如果一个对象具有 next 方法，并且该方法返回一个对象，该对象的格式如下：

```js
{value: 值, done: 是否迭代完成}
```

则认为该对象是一个迭代器

含义：

- `next`方法：用于得到下一个数据
- 返回的对象
  - `value`：下一个数据的值
  - `done`：boolean，是否迭代完成

```js
const arr = [1, 2, 3, 4, 5];
//迭代数组arr
const iterator = {
  i: 0, //当前的数组下标
  next() {
    var result = {
      value: arr[this.i],
      done: this.i >= arr.length,
    };
    this.i++;
    return result;
  },
};

//让迭代器不断的取出下一个数据，直到没有数据为止
let data = iterator.next();
while (!data.done) {
  //只要没有迭代完成，则取出数据
  console.log(data.value);
  //进行下一次迭代
  data = iterator.next();
}

console.log('迭代完成');
```

迭代器是数据与操作过程分离，不需要每次都重新写一遍操作过程

```js
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [6, 7, 8, 9];

// 迭代器创建函数  iterator creator
function createIterator(arr) {
  let i = 0; //当前的数组下标
  return {
    next() {
      var result = {
        value: arr[i],
        done: i >= arr.length,
      };
      i++;
      return result;
    },
  };
}

const iter1 = createIterator(arr1);
const iter2 = createIterator(arr2);
```

例子：依次得到斐波拉契数列前面 n 位的值

```js
// 依次得到斐波拉契数列前面n位的值
// 1 1 2 3 5 8 13 .....

//创建一个斐波拉契数列的迭代器
function createFeiboIterator() {
  let prev1 = 1,
    prev2 = 1, //当前位置的前1位和前2位
    n = 1; //当前是第几位

  return {
    next() {
      let value;
      if (n <= 2) {
        value = 1;
      } else {
        value = prev1 + prev2;
      }
      const result = {
        value,
        done: false,
      };
      prev2 = prev1;
      prev1 = result.value;
      n++;
      return result;
    },
  };
}

const iterator = createFeiboIterator();
```
